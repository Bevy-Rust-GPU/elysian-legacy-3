* Refactor domain types as trait impls
  * Semantically similar to context, i.e. a set of types
  * Will avoid having to implement combinators over (Distance, D)
  * Should allow replacing (DistanceF32, (GradientF32, ()) with PosDistGrad
    * Feels like Input / Field / Output taking multiple values may complicate this

  DONE: Attempted, but ended up creating type aliases for lists,
        as Combine subtypes need to pattern-match an ADT in order to deconflict their impls

* Elide Input / Output / Field wrapping for API purposes
  * Structs still need to exist for ADT purposes
  * Need an ADT lifting function that can be called inside the Shr impl

  DONE: Implemented via shape builder wrapper and Shr operator

* Formalize rasterize, ascii, image, viuer into new ADT subtype
  * Interpreter is the wrong term
  * Semantically a Context -> Context operation
    * Similar to domain-lifted Input / Output / Field functions,
      and composable with them
  * Supertype of all existing ADT ops?
    * Devil's advocate says this is overcomplicated and should be omitted
      in favour of simple function composition
      * However, it's still useful as ADT for the following reasons:
        * Chaining multiple actions within a context (i.e. nesting inside Shape, Combine)
        * Use of output within a context
          * ex:
            Texture mapping via Raster + Uv + Color
            Conversion to a mesh for LOD / optimization purposes under software rasterization
            Rendering generated ascii as distance field characters
            Using texture lookup as an alternative to domain evaluation
        * Breaking specific entries out of a context to leave the ADT and continue via simple composition

  DONE: Implemented Modify as an ADT unit, but not useful for rasterize etc
        since they evaluate an ADT rather than modifying a context.
        However, this realizes Get, Set and related lifted functions as Modify subtypes.

* Make Combine operation types symbolic
  * Lift via trait, similar to domain functions
  * Allows the ADT to remain a Free structure
  * Allows formalization of interpreters over free structure

  DONE: Combine ops are now lifted into the register machine interpreter via the LiftCombine trait

* Strengthen Input / Field / Output encoding
  * Create specific traits to replace Domain
    * LiftInput / LiftOutput / LiftField
    * Allows relating of open symbol types to closed ADT wrappers
  * Feels like it relates to a prospective output type encoding,
    since the promise is that A flows through Inputs,
    is transformed into B by Field, then flows through Outputs
  
  DONE: Encoded via LiftAdt, since lifting into a wrapper and lifting into functions are distinct

* Parameter substitution for symbolic ADT inner types
  * Use functions instead of literals
    * Ex. Isosurface(Const(0.2)) instead of Isosurface(0.2)
  * Lift to context functions and evaluate as part of overall graph
  * Using functions allows arbitrary value transformation before use as input
  * Opens the door to functional reactive programming
    * Animation system by using time as a parameter
  * Can use Tagged types for named variables
    * ex. Tagged<ProjectionMatrix, Mat4> for raymarching, corresponding GetF<ProjectionMatrix>
    * May be able to replace DistanceF32 etc with true symbol types

  DONE: Parameters are now functions, and get lifted via LiftParam during evaluation

* ADT de/serialization via serde
  * Opens the door to an Elysian file type, FFI, etc

  DONE: Derived Serialize / Deserialize for all ADT structs and symbols

* Investigate generalized chaining framework based on Do / AdtBuilder
  * Could act as a viable alternative to Haskell's customizable operators
  * Use a single operator, or perhaps two to control associativity (i.e. Shl / Shr)
  * Use operation symbol types (ex. DoFmap, DoApply) to represent binary ops
  * Symbol types become a wrapper when operated on
  * Wrapper type applies binary op when operated on
  * Terminating type (ex. Done) to morph between wrappers or unwrap

  DONE: Implemented in t_funk::r#do

* Refactor operator overloads as Do subtypes

  DONE: Operator overloads replaced with Do-able trait operators

* Refactor ADT to split Input / Field / Output into a sub-ADT
  * Currently impractical to implement Monad etc
  * Input / Field / Output is essentially equivalent to Modify
  * May need to give the outer ADT a terminating type to satisfy Mempty

  DONE: Input / Field / Output are now resposible for enforcing their A -> B semantics

* Create macros to simplify creating identical impls for multiple ADT subclasses
  
  DONE: define_adt for defining multiple structs with the same attributes,
        impl_adt for creating identical impls for multiple structs at once

* Create dual of function attribute macro to lift functions to the type level
  * i.e. Annotate a generic function, get a trait, FunctionF and FunctionT types
  * Will also need a free-standing version to lift functions defined in other crates

  DONE: Implemented as t_funk::macros::lift, refactored existing impls accordingly

* Try to unify lifting functions so monad instance is transparent
  * i.e. Should be able to chain from ADT -> List -> ADT
         Should also be able to compose ADTs with a single Do function
  
  DONE: All ADT elements now lift in a unified manner.
        In addition, various core rust types can now lift transparently into paramters.

* Finalize Semigroup / Monoid instances for ADT

  DONE: Formalized Compose impls with doctests, so Semigroup and Monoid
        strictly offload to other classes, so are in and of themselves robust.

* Finalize Monad instance for ADT

  DONE: ADT can freely chain to a const list representation and back

* Investigate Applicative instance for ADT

  DONE: Implemented based on list instance, using Modify for Pure

* Refactor * -> Sequence composition to match on compatible types
  
  DONE: Implemented bounds on existing traits

* Investigate monad transformers
  * Using independently-provable building blocks seems idiomatic to FP
  * May be able to reduce explicit / arbitrary ADT into fundamental typeclasses and instances

  DONE: Seems useful for extending an explicit ADT with the properties of a given monad,
        but potentially clunky if used with primitives like Tagged as a first-class building block.
        Explicit ADT seems preferable for the sake of readable API,
        but a primitive building block approach has potential for IR transformations.

* Replace tuple-based vectors / points with glam structs

  DONE: Refactored associated wrappers to be unary, integrated glam types

* Rework Input / Field / Output as a free-standing abstraction,
  host inside Modify when lifting to ADT
  * Already semantically equavalent to Modify - i.e. a C -> C - just with stronger encoding

  DONE: Implementing double-lifting to go from symbol -> Shape -> ADT,
        refactored composition accordingly

* Investigate Alternative and MonadPlus
  * Combine subtypes seem like they have a strong relation to these typeclasses

  DONE: Useful to know about, but only useful in cases where the binary op is intuitive.
        This would be the case for Combine if it was just <A, B>,
        but being parametrized over an additional F prevents it.

=======================================================================================================================

* Refactor context lifting to be transparent
  * Currently occurs inside LiftDomainFunctions, which is called by LiftDomains
    * This makes it specific to shapes, when it should be specific to context modifiers
  * Run is the intuitive place to put it, but doesn't line up with existing idioms
    * GetContext / SetContext specifically
      * These specialize around using the t-funk Get / Set functions directly
    * Looked at splitting Run into Read / Write / Modify, but doesn't make sense.
      * Read is equivalent to piping the output of Get into some function
      * Write would have nowhere to get parameters from except the context
    * Primary goal here is to allow general modifiers the same
      automatic context lifting interface as shape functions,
      rather than having to use the Get / Set traits directly
      * In which case, reintroducing a Modify newtype as a sibling of Shape
        may be the best solution, since the levels of wrapping are currently lopsided
        w.r.t. open types.

* Rework rasterize, ascii, viuer as functions that operate on a context
  * Intent is to make them part of the ADT, since rasterize takes a base context
  * Store Raster in context and operate on it instead of simply producing it
  * Modify(Rasterize(SHAPE_ADT)) << Modify(Ascii) << Modify(PrintLn)?
    * Would require storing String in context to hold Ascii output
    * Likewise with image types for Viuer
    * Notably, this would be a separate domain-specific context in each case
    * Allows composition, i.e. sampling the raster as a texture using the UVs of some parent shape
      * However, this would only make sense if statically evaluating the raster or providing a pre-baked texture,
        since evaluating the child ADT directly from the parent would produce better results.
    * As with the existing code, this layer should be free, i.e. symbol-based
      * Allows exotic interpretations like rasterizing into a texture,
        then feeding it into a shader rendering a shape ADT
        that would normally consume the rasterization as child data

* Distance + Color evaluation

* Simple lighting model for rendering 2D fields
  * Concrete case for use of normal and color

* Abstract over multi-frame evaluation
  * ex:
    Generating a series of images for ascii / viuer printing
    Generating an animated GIF for viuer printing
  * Can use a parameter function to retrieve time from context and parametrize
  * This is higher-order operation over image-generating contexts
    * Uses another distinct context of its own, likely containing a list / array of outputs

* Investigate refactoring register machine interpreter into a State monad impl
  * Effectively equivalent - drags a state (i.e. context) through a chain of functions,
    which can be lifted to operate on the state
  * May need a StateT transformer to make this ergonomic
    * Maybe not - need to puzzle out the types involved and see what's ideal
  * If any notable code remains after refactor,
    it should be split into a free-standing register machine abstraction

* Improve functions macro
  * Should be able to cover all cases present in t-funk and elysian

* Revisit autogenerated type suffixes
  * FooT conflicts with the T suffix for monad transformers
    * Perhaps better as FooR or FooO to indicate that it represents return / output

* Consider extending impl_adt! to resemble match syntax
  * pub struct Elysian {
        Foo | Bar | Baz => {
        } where
            Foo: Clone,
        Nil => {}
    }
  * Move existing Foo | Bar | Baz parse to the left of => and the corresponding impl to the right,
    parse multiple blocks
  * Unsure about where clause, needs to be per-block, but seems unergonomic

* Improve lift macro to use PhantomData for handling non-bound types
  * Still a valid Function impl, since a self receiver is not needed

* Better list abstraction for t-funk
  * Need a unified set of interfaces that can be implemented by HList and nested tuples
  * Ideally also regular tuples, though that may raise conflicts between approaches

* R&D for proxy application
  * Semantically, this is a combine operation that
    evaluates shapes A and B, and replaces or blends
    some subset of shape B's context into shape A's context
  * In theory, this is a superset of distance boolean / bounding operators
    i.e. Replacing distance in the case of regular boolean,
         and blending it in the case of smooth boolean
    * Could generalize Boolean to arbitrary domain types, make combine functions composable
      * How to handle dragging the rest of the context through?
        * Seems like an additional semantic on top of the binary op
          i.e. whichever succeeds also brings the rest of its context

* Haskell diagrams R&D
  * Lots of food for thought in the documentation
    * https://archives.haskell.org/projects.haskell.org/diagrams/doc/quickstart.html
  * Attribute injection
    * Currently handled by Set, but largely unproven
  * Local origins
  * Envelope-based layout
    * Alignment (i.e. envelope fit vs plane)
  * Snug fit via raycasting
  * Monoid composition
  * Points
  * Segments
  * Lines
  * Splines
  * Loops
  * Trails
  * Paths
  * Arrows

* Formalize interpretation of free structure
  * Existing type-level register machine behaviour is an interpreter
  * Could this be unified under Interpret and Interpreter traits?
    * Traversable is likely relevant here
  * Alternate interpreters:
    * Dynamic structuring
      * Convert ADT into a type-erased value-level equivalent (ex. dyn / impl Trait)
        * Useful for runtime editing,
          though may not be mandatory if strongly-typed recursive control flow is viable
    * EDSL graph visualizer
      * Create a new EDSL visualizing the graph as UI primitives
    * Graph optimizer
    * Bevy hierarchy generator
      * Interpret boolean union as breaking a child out of its parent hierarchy
    * Static evaluation
      * Pre-evaluate expensive operations
        * ex. Layout:
          Replace a Combine<A, B, AxialFit> with Combine<Shape<Translate, A>, Shape<Translate, B>, Union>
          * Where AxialFit is semantically equivalent to raycast-based layout from Haskell diagrams
          * This raises the question of how AxialFit relates to Union
            * Suggests the need for composable Combine subtypes?
              * Devil's advocate says this may be overkill,
                since ex. horizontal layout aims to avoid overlap
              * However, making it compositional strengthens semantics
                and eases implementation for coupled cases
                (i.e. via type alias or function call wrapping)
          * Code should be shareable between runtime and static evaluation

* ADT parsing via nom
  * Opens the door to creating a specialized CLI REPL
